+++
title = "Serverless简单介绍"
date = "2022-03-03"
description = ""
toc = true
tags = [
    "serverless",
    "云原生",
]
+++

serverless分为FASS BASS PASS
不是不需要服务器, 而是不需要管理服务器.

## 核心价值
简化运维
弹性伸缩
按需付费

## 特点
* 按需加载
* 事件驱动
* 应用无状态
* 自动弹性伸缩

## BASS
backend as a service 后端即服务
BaaS提供应用依赖的第三方服务, 如数据库, 缓存, 消息队列, 文件存储, 身份认证, 分析, 云函数等, 通常有云服务商提供, 或者第三方提供.
与PaaS的区别是,PaaS需要使用者管理服务的生命周期, 而BasS只需要使用服务.

## FASS
function as a server
例如:AWS Lambda，Google Cloud Functions，Azure Functions, alyun FC

## 面临的问题
* 难以移植，与云服务商绑定
  通常serverless是云服务商提供的, 云服务商的serverless产品不兼容. 
  服务商提供一系列可供快速使用产品作为服务, 接口通常是专有的,不会与其他服务商兼容.
  好在，现在有开源的serverless平台, 各云服务商都可使用。或者使用自定义的container运行时,也可以减少对云服务商的依赖.
* 缺少控制力
由于用户只需关注代码，也意味着用户无法控制运行的底层环境。
除了代码之外的一切，都发生了质变，意味着工作流程的巨大变化。事实上，代码也变了，如果使用专有的serverless框架，那么对于`事件`的处理方式，与原方式不同。
调试，测试，应用监控，日志，中间件都与以往不同。
## serverless框架

* serverless devs
阿里云开源, 支持多云, 支持多语言, 支持多平台, 支持多种运行时.
* serverless framework
*   AWS Lambda，最早被大众所认可的 Serverless 实现。
*   Azure Functions，来自微软公有云的 Serverless 实现。
*   OpenWhisk，Apache 社区的开源 Serverless 框架。
*   Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。
*   Fission，Platform9 推出的开源 Serverless 框架。
*   OpenFaaS，以容器技术为核心的开源 Serverless 框架。
* Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发
  
## FASS详解

### 概念
* 服务
  * 服务由多个函数组成. 创建函数之前必须先创建服务
  
* 函数
  * 类型
    * 事件函数    
    * http函数
  
* 请求处理程序
  * 即用户代码
  * 函数计算的运行时,会调用请求处理程序,处理函数.
  * 请求处理程序分为两种
    * 事件请求处理程序
    * HTTP请求处理程序
  
* 版本 服务的版本. 对服务配置,函数配置,请求处理程序的版本管理

* 别名 执行某个版本的指针.

* 层 把公共依赖,运行时环境抽到层中,统一管理. 可以减少部署时的代码体积.

* 事件源 事件的生产者.

* 触发器 事件发生后, 如果满足触发器规则, 则会调用对用的函数.

* 冷启动 在函数调用链路中的代码下载、启动函数实例、进程初始化及代码初始化等环节.
  * 当冷启动完成后，函数实例就绪，后续请求就能直接被函数执行.
  * 冷启动时间是服务可用性的关键指标. 这导致JVM天生不适合serverless.
  
  运行时 函数运行环境
  
  * 各种语言的运行时. 如nodejs jvm golang python有不同的运行时和版本.
  * custom runtime. 用户自定义的语言运行时.
  * custom container. 用户自定义的容器运行时.
  
* 模式
  * 按量模式
    * 按照调用次数和运行时间计费. 用于冷启动很快的服务.
  * 预留模式
    * 至少保留若干个服务实例, 当函数调用时, 优先调用预留实例. 当请求较多, 超过预留实例的处理能力时, 会把请求转到按量模式的实例上.
    * 用于冷启动较慢, 以及需要定时任务的服务.
    * 可以启用"闲置模式", 为实例分配极低的cpu资源, 用于降低成本. 需要进行函数计算时, 会自动恢复cpu资源.

### 服务管理

对服务的各种方面进行管理
`日志 版本 别名 网络 公网IP域名 存储 `
创建服务时,通过yaml文件对服务进行配置. 

#### runtime

* 默认runtime
直接上传编译后的代码即可.
* 自定义runtime
需要把语言的执行程序与代码一起打包上传.
代码必然是http server程序, 所以函数入口配置的handler是没有实际意义的. 
http请求和事件请求都是通过http接口来处理的. 事件请求调用的接口为``
* 自定义容器runtime
通过容器定义任何runtime.
在该runtime下, 原本的程序迁移到serverless, 无需修改代码, 通过http接口与函数计算系统交互. 

`语言runtime`是由函数计算服务定义实时的运行环境, 而`容器runtime`是由容器定义运行环境,所以相关的所有配置方式都不一样.

### 函数管理

#### 层管理

在语言runtime下, 需要进行层管理. 在容器runtime下,一切由定制的容器管理, 不需要层管理.

### 函数调用

可同步和异步调用.异步调用支持多种方式回调. 异步调用方式可用于定时任务, 和延迟执行(类似延迟队列/消息)

## 思考

* FaaS如何节省云服务商的成本?
  在非预留模式下, 用户代码是不存活的. 只有当函数调用的时候, 才会进行启动.
  所以本质上是云服务商使用另外的服务器在运行监听服务, 接收http请求和事件. 而这个服务器是共享的, 就可以根据用户服务的函数负载, 动态调度监听服务器的数量.

* java应用使用FaaS
  java云原生亲和力很差, 现阶段不适合使用serverless. 
  * 由于冷启动速度太慢, 必须有预留实例. 对于流量低的服务，达不到节省成本的效果。
  * 占用内存很大, 所以需要配置更高的服务实例.
  * aliyun serverless 默认不开启内网调用, 而且各服务暴露出的地址是url连接, 这都导致微服务间调用比较麻烦. 只有当服务的高峰与低谷期负载差异很大时,才能有效节省成本. 对于中小公司以及服务负载不大的, 不能节省成本.
  * 使用graalvm后,java的启动速度以及内存占用都有了很大的提升。但现在不成熟，难以应用到生产环境。
  
* 使用serverless的哪种runtime
  使用容器runtime, 对serverless框架没有任意依赖性. 所有相关配置与函数运行环境无关. 直接把容器放在函数计算环境下运行即可.



## 延伸:Iaas Paas Saas Faas Baas

从上到下, 定制型降低(不包括Faas)

Iaas 架构即服务

Paas 平台即服务. 提供应用运行的所有环境, 伸缩, 负载均衡.  软件的开发和运行与传统开发差异较小.

Baas 后台即服务. 提供后台各种能力. 如数据存储, 消息推送, 日志抓取. 例如小程序

Saas 软件即服务. 通常是网站的形式,对客户来说开箱即用. 不面向开发者.

Faas 函数即服务.

Serverless 相比于Paas, 更进一步减弱server的影响. 开发者只需要关注代码本身, 其他全都不用关注, 这也导致serverless软件开发与传统开发方式有巨大变化. 包括Faas Baas
